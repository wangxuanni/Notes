---
title: 多线程基础概念
date: 2019-02-11 23:53:50
categories: 并发
description: 多线程基础概念
---
# 进程

## 进程和线程的关系与区别？

进程是资源分配的最小单元。线程是CPU调度的最小单元，一个Java程序对应着一个进程。

| 对比维度       | 多进程                                                       |                     多线程                     |
| -------------- | ------------------------------------------------------------ | :--------------------------------------------: |
| 数据共享、同步 | 数据共享复杂，需要用IPC；数据是分开的，同步简单              | 因为共享进程数据，数据共享简单，但也是同步复杂 |
| 内存、CPU      | 进程切换复杂，CPU利用率低                                    |                  线程切换简单                  |
| 创建销毁、切换 | 创建销毁、切换复杂速度慢                                     |            创建销毁、切换简单速度快            |
| 编程、调试     | 编程简单，调试简单                                           |               编程复杂，调试复杂               |
| 可靠性         | 进程间不会互相影响                                           |         一个线程挂掉将导致整个进程挂掉         |
| 分布式         | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 |                适应于多核分布式                |

## 进程间的通信方式

1. **匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
1. **命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。
1. **消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**
1. **共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**
1. **信号量**可以保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。
1. **信号**，与信号量名字很相似，它俩名字虽然相似，但功能一点儿都不一样。信号是**异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SIGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。
1. **Socket 通信**。前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要socket了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。



## 子进程

使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。

子进程与父进程的区别在于：

1、父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）

2、进程ID和父进程ID不同

3、子进程的未决告警被清除；

4、子进程的未决信号集设置为空集。

## 协程

协程是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程，Golang语言支持协程**一个线程中的多个协程的运行是串行的**。 

协程的优势如下：

- 节省 CPU：协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。

- 节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。

- 稳定性：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。

- 开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

  

  https://segmentfault.com/a/1190000040373756



## 僵尸进程

一个进程结束了，但是他的父进程没有等待（调用wait / waitpid）他，那么他将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表 （processs table）中仍占了一个位置（slot）。

如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。

https://cloud.tencent.com/developer/article/1722245



## 线程状态

**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。

**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

**阻塞(BLOCKED)**：表示线程阻塞于锁。
**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

- Object.wait with no timeout
- Thread.join with no timeout
- LockSupport.park

**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。

- Thread.sleep
- Object.wait with timeout
- Thread.join with timeout
- LockSupport.parkNanos
- LockSupport.parkUntil

**终止(TERMINATED)**：表示该线程已经执行完毕。

这6种状态定义在Thread类的State枚举中，可查看源码进行一一对应。

## 

![线程状态图](https://segmentfault.com/img/remote/1460000023194699)

### BLOCKED与WAITING的区别

BLOCKED是指线程正在等待获取锁；WAITING是指线程正在等待其他线程发来的通知（notify），收到通知后，可能会顺序向后执行（RUNNABLE），也可能会再次获取锁，进而被阻塞住（BLOCKED）。	

# 死锁

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用两个事务都无法推进，这样就产生了死锁。

## 四个必要条件

四个条件缩写”一球夺环“

1. 互斥条件：即任何时刻，一个资源只能被一个进程使用。其他进程必须等待。
2. 请求和保持条件：即当资源请求者在请求其他的资源的同时保持对原有资源的占有且不释放。
3. 不剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
4. 环路等待条件：比如A占有B在等待的资源（B等待A释放），B占有A在等待的资源（A等待B释放）。多个进程循环等待着相邻进程占用着的资源。

避免死锁可以通过破环四个必要条件之一。

## 解决死锁的方法

1. 加锁顺序保持一致。不同的加锁顺序很可能导致死锁，比如哲学家问题：A先申请筷子1在申请筷子2，而B先申请筷子2在申请筷子1，最后谁也得不到一双筷子（同时拥有筷子1和筷子2）

2. 超时，为其中一个事务设置等待时间，若超过这个阈值事务就回滚，另一个等待的事务就能得以继续执行。比如可重入锁的超时等待

3. 数据库可以及时检测出死锁，选择一个牺牲者放弃事务，即回滚undo量最小的事务。一般是用等待图（wait-for gragh）深度优先搜索的算法实现，如果图中有环路就说明存在死锁。



## 虚拟内存



虚拟内存是操作系统分配给进程的一个虚拟地址，真正的进程和物理内存的映射维护在操作系统里。

之所以需要虚拟内存是为了让进程不直接操作内存，否则就无法将各个进程隔离。

虚拟地址空间的映射是以分段和分页两种方式结合，分段会产生空间碎片，分页需要用到多级页表。根据程序局部性原理，在CPU里加入TLB，复制管理最近被访问的页表项。

CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。

在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分。进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间的内存；

虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA

# 用户态与内核态

## 为什么会有用户态和内核态？

操作系统不信任用户操作，用户只有低权限操作，当需要做高权限操作时，会切换到内核态。

比如进程中要读写 I O，需要用到 ring 0 级别的 C P U 指令集， C P U 切换指令集操作权限级别为 ring 0，C P U再执行相应的ring 0 级别的 C P U 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。

PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用

## 用户态和内核态切换的开销大在哪里？

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）

## 什么情况会导致用户态到内核态切换

- 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断
- 异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
- 中断：中断是什么？操作系统收到中断请求会停止当前执行的程序，去执行中断请求的程序。比如说磁盘控制器把数据放到内部缓冲区中，会产生一个中断；CPU 收到中断信号后，停下手头的工作，接着把磁盘的数据写入到内存。为什么中断会导致用户态切换？因为所有中断服务程序都属于内核代码。



[从根上理解用户态与内核态](https://segmentfault.com/a/1190000039774784)



