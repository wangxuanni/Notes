热key

热 Key 请求是指90%的流量都集中请求10%的数据，导致大部分流量落到同一个 Redis 实例上，资源分配不均导致出现性能短板；

## 检测

- 提前预知，比如秒杀活动这种场景，我们可以提前预知热点的key。
- 监控自动感知，比如热点事件这种无法预估的，只能使用监控自动化发现热点key。



## 问题解决方案

### 增加副本数量

通过水平扩容增加副本数量，防止出现流量倾斜的情况，将读请求的压力打散到不同副本所在的节点上。

- 用户体验，根据用户id取余决定访问哪个副本，每个用户每次访问的都保持一致，防止出现用户短时间内看到数据不停变化。
- 过期策略，副本的过期时间是 hotkey 的过期时间加上一个较小的随机正整数，这是通过坡度过期的方式，保证在 hotkey 过期时，所有 bakHotKey 不会同时过期而造成缓存雪崩。
- 不一致性，当子key读取数据为null时，从主key读取数据，写入子key并返回，如果主key没有value，触发整套写逻辑，完成写逻辑后返回数据。写的成功与否，只关心主key的成功与否，忽略子key操作结果
- 可配置化，打散副本数，热点主播id、直播间id、商品id支持可配置化。
- 提供强制读hotkey方法。



### 二级缓存（本地缓存）

当出现热 Key 以后，把热 Key 加载到系统的 JVM 中。后续针对这些热 Key 的请求，会直接从 JVM 中获取，而不会走到 Redis 层。这些本地缓存的工具很多，比如 Ehcache，或者 Google Guava 中 Cache 工具，或者直接使用 HashMap 作为本地缓存工具都是可以的。

使用本地缓存需要注意两个问题：

- 如果对热 Key 进行本地缓存，需要防止本地缓存过大，影响系统性能；
- 需要处理本地缓存和 Redis 集群数据的一致性问题。



## 监控自动感知

### hotkeys 参数

Redis 在 4.0.3 版本中添加了 hotkeys 查找特性，可以直接利用 redis-cli --hotkeys 获取当前 keyspace 的热点 key，实现上是通过 scan + object freq 完成的。

优点：无需进行二次开发，能够直接利用现成的工具；

缺点：

-   由于需要扫描整个 keyspace，实时性上比较差;
-   扫描时间与 key 的数量正相关，如果 key 的数量比较多，耗时可能会非常长。

### monitor 命令

monitor 命令可以实时抓取出 Redis 服务器接收到的命令，通过 redis-cli monitor 抓取数据，同时结合一些现成的分析工具，比如 redis-faina，统计出热 Key。

优点：无需进行二次开发，能够直接利用现成的工具；

缺点：该命令在高并发的条件下，有内存增暴增的隐患，还会降低 Redis 的性能。

### Redis 节点抓包分析

Redis 客户端使用 TCP 协议与服务端进行交互，通信协议采用的是 RESP 协议。自己写程序监听端口，按照 RESP 协议规则解析数据，进行分析。或者我们可以使用一些抓包工具，比如 tcpdump 工具，抓取一段时间内的流量进行解析。

优点：对 SDK 或者 Proxy 代理层没有入侵；

缺点：

- 有一定的开发成本；
- 热 Key 节点的网络流量和系统负载已经比较高了，抓包可能会导致情况进一步恶化。







